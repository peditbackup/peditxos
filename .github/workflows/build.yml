# .github/workflows/build.yml (Final Version using Node.js and Google Cloud Library)

name: 'PeDitXOS Firmware Builder'

on:
  workflow_dispatch:
    inputs:
      user_id:
        description: 'Firebase User ID'
        required: true
        type: string
      build_id:
        description: 'Firestore Build ID'
        required: true
        type: string
      device_target:
        description: 'Device Target'
        required: true
        type: string
      device_profile:
        description: 'Device Profile'
        required: true
        type: string
      target_arch:
        description: 'Target Architecture'
        required: true
        type: string
      openwrt_version:
        description: 'OpenWrt Version'
        required: true
        type: string
      extra_packages:
        description: 'Extra packages'
        required: false
        type: string
      theme_choice:
        description: 'Selected LuCI theme'
        required: true
        type: string
      lan_ip:
        description: 'The LAN IP address'
        required: false
        type: string
      wifi_24_enabled:
        description: 'Enable 2.4GHz WiFi'
        required: false
        type: string

jobs:
  build_firmware:
    name: Build Firmware
    runs-on: ubuntu-latest

    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4

      - name: 'Install Build Dependencies'
        run: |
          sudo apt-get update
          sudo apt-get install -y wget tar make coreutils rsync openssh-client curl jq zstd unzip

      - name: 'Download and Extract OpenWrt ImageBuilder'
        id: download_ib
        run: |
          TARGET_DIR_URL="https://downloads.openwrt.org/releases/${{ github.event.inputs.openwrt_version }}/targets/${{ github.event.inputs.device_target }}"
          IMAGEBUILDER_FILENAME=$(curl -s "${TARGET_DIR_URL}/" | grep -o 'href="[^"]*imagebuilder[^"]*\.tar\.\(xz\|zst\)"' | head -n 1 | sed 's/href="//;s/"//')
          if [ -z "$IMAGEBUILDER_FILENAME" ]; then
            echo "::error::Could not automatically find the ImageBuilder filename."
            exit 1
          fi
          echo "IMAGEBUILDER_FILENAME=${IMAGEBUILDER_FILENAME}" >> $GITHUB_OUTPUT
          IMAGEBUILDER_URL="${TARGET_DIR_URL}/${IMAGEBUILDER_FILENAME}"
          wget "${IMAGEBUILDER_URL}"
          mkdir imagebuilder
          tar -xf "${IMAGEBUILDER_FILENAME}" --strip-components=1 -C imagebuilder

      - name: 'Prepare ImageBuilder Environment'
        run: |
          IMAGEBUILDER_DIR="imagebuilder"
          echo "IMAGEBUILDER_DIR=${IMAGEBUILDER_DIR}" >> $GITHUB_ENV
          TARGET_ARCH="${{ github.event.inputs.target_arch }}"
          echo "TARGET_ARCH=${TARGET_ARCH}" >> $GITHUB_ENV
          REPO_CONF_FILE="${IMAGEBUILDER_DIR}/repositories.conf"
          sed -i 's/^option check_signature.*/option check_signature 0/' "${REPO_CONF_FILE}"
          echo "--- Signature check disabled ---"

      - name: 'Generate Custom UCI Defaults Script'
        run: |
          UCI_SCRIPT_DIR="${{ github.workspace }}/files/etc/uci-defaults"
          mkdir -p "${UCI_SCRIPT_DIR}"
          UCI_SCRIPT_PATH="${UCI_SCRIPT_DIR}/99-peditxos-settings"
          
          echo "#!/bin/sh" > "${UCI_SCRIPT_PATH}"
          echo "uci -q batch <<EOF" >> "${UCI_SCRIPT_PATH}"
          echo "set system.@system[0].hostname='PeDitXOS'" >> "${UCI_SCRIPT_PATH}"
          if [ -n "${{ github.event.inputs.lan_ip }}" ]; then
            echo "set network.lan.ipaddr='${{ github.event.inputs.lan_ip }}'" >> "${UCI_SCRIPT_PATH}"
          fi
          if [ "${{ github.event.inputs.wifi_24_enabled }}" = "false" ]; then
            echo "set wireless.radio0.disabled='1'" >> "${UCI_SCRIPT_PATH}"
          fi
          echo "commit" >> "${UCI_SCRIPT_PATH}"
          echo "EOF" >> "${UCI_SCRIPT_PATH}"
          chmod +x "${UCI_SCRIPT_PATH}"
          echo "--- Custom settings script generated ---"
          cat "${UCI_SCRIPT_PATH}"

      - name: 'Download Custom IPK Packages'
        run: |
          CUSTOM_PKG_DIR="${{ env.IMAGEBUILDER_DIR }}/packages"
          mkdir -p "${CUSTOM_PKG_DIR}"
          download_latest_ipk() {
            local REPO_NAME="$1"
            local API_URL="https://api.github.com/repos/peditx/${REPO_NAME}/releases/latest"
            local IPK_URL=$(curl -sL "$API_URL" | jq -r '.assets[] | select(.name | endswith(".ipk")) | .browser_download_url' | head -n 1)
            if [ -n "$IPK_URL" ]; then
              wget -q "$IPK_URL" -P "${CUSTOM_PKG_DIR}"
            fi
          }
          download_passwall_bundle() {
            local PASSWALL_REPO="$1"
            echo "--> Downloading main package and dependency bundle for ${PASSWALL_REPO}..."
            download_latest_ipk "${PASSWALL_REPO}"
            API_URL="https://api.github.com/repos/peditx/${PASSWALL_REPO}/releases/latest"
            ZIP_FILENAME="passwall_packages_ipk_${{ env.TARGET_ARCH }}.zip"
            ZIP_URL=$(curl -sL "$API_URL" | jq -r --arg FILENAME "${ZIP_FILENAME}" '.assets[] | select(.name == $FILENAME) | .browser_download_url')
            if [ -n "$ZIP_URL" ]; then
              wget -q "${ZIP_URL}" -O dependencies.zip
              unzip -o dependencies.zip -d "${CUSTOM_PKG_DIR}"
              rm dependencies.zip
            else
              echo "::warning::Could not find dependency bundle for ${PASSWALL_REPO}."
            fi
          }
          download_latest_ipk "luci-theme-peditx"
          download_latest_ipk "luci-theme-carbonpx"
          DOWNLOAD_V1="false"
          DOWNLOAD_V2="false"
          for pkg in ${{ github.event.inputs.extra_packages }}; do
            if [[ "$pkg" == "luci-app-passwall" ]]; then
              DOWNLOAD_V1="true"
            fi
            if [[ "$pkg" == "luci-app-passwall2" ]]; then
              DOWNLOAD_V2="true"
            fi
          done
          if [[ "$DOWNLOAD_V1" == "true" ]]; then
            echo "--> Passwall v1 is requested. Downloading..."
            download_passwall_bundle "openwrt-passwall"
          fi
          if [[ "$DOWNLOAD_V2" == "true" ]]; then
            echo "--> Passwall v2 is requested. Downloading..."
            download_passwall_bundle "openwrt-passwall2"
          fi
      
      - name: 'Build Firmware Image'
        run: |
          cd "${{ env.IMAGEBUILDER_DIR }}"
          make clean
          BASE_PACKAGES="luci luci-ssl luci-compat curl screen sshpass procps-ng-pkill luci-app-ttyd coreutils coreutils-base64 coreutils-nohup"
          ALL_PACKAGES="${BASE_PACKAGES} -luci-theme-bootstrap -dnsmasq ${{ github.event.inputs.theme_choice }} ${{ github.event.inputs.extra_packages }}"
          echo "Building with Profile: ${{ github.event.inputs.device_profile }}"
          echo "Final Packages: ${ALL_PACKAGES}"
          make image PROFILE="${{ github.event.inputs.device_profile }}" \
            PACKAGES="${ALL_PACKAGES}" \
            FILES="${{ github.workspace }}/files" \
            BIN_DIR="${{ github.workspace }}/output" V=s

      - name: 'List Output Directory Contents'
        if: always()
        run: |
          echo "--- Listing contents of output directory ---"
          ls -R ${{ github.workspace }}/output

      - name: 'Organize and Rename Output Files'
        id: organize_files
        run: |
          cd "${{ github.workspace }}/output"
          if [ -z "$(ls -A .)" ]; then 
            echo "::error::Build failed, no files were generated."
            exit 1
          fi
          SYSUPGRADE_FILE=$(find . -name "*sysupgrade.bin*" | head -n 1)
          if [ -z "$SYSUPGRADE_FILE" ]; then
            echo "::error::Sysupgrade file not found!"
            exit 1
          fi
          SYSUPGRADE_FILE=${SYSUPGRADE_FILE#./}
          echo "SYSUPGRADE_FILE=${SYSUPGRADE_FILE}" >> $GITHUB_OUTPUT
          for f in openwrt-*; do mv -- "$f" "PeDitXOS-${f#openwrt-}"; done
          RENAMED_FILE="PeDitXOS-${SYSUPGRADE_FILE#openwrt-}"
          echo "RENAMED_FILE=${RENAMED_FILE}" >> $GITHUB_OUTPUT
          rm -f *.json

      - name: 'Upload Firmware to SourceForge'
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SF_USERNAME: ${{ secrets.SF_USERNAME }}
          SF_PROJECT_NAME: ${{ secrets.SF_PROJECT_NAME }}
        run: |
          mkdir -p ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H frs.sourceforge.net >> ~/.ssh/known_hosts
          REMOTE_DIR="/home/frs/project/${SF_PROJECT_NAME}/${{ github.event.inputs.openwrt_version }}/${{ github.event.inputs.device_profile }}/"
          rsync -avz --progress -e "ssh -i ~/.ssh/id_rsa -o IdentitiesOnly=yes" \
            "${{ github.workspace }}/output/" \
            "${SF_USERNAME}@frs.sourceforge.net:${REMOTE_DIR}"
          echo "Upload complete."

      # <<< MODIFIED: Switched to a Node.js script for reliability
      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: 'Install Firestore Library'
        run: npm install @google-cloud/firestore

      - name: 'Report Success to Firestore'
        uses: actions/github-script@v7
        with:
          script: |
            const { Firestore } = require('@google-cloud/firestore');
            const firestore = new Firestore({
              projectId: 'peditxos',
              credentials: JSON.parse('${{ secrets.GCP_SA_KEY }}')
            });
            const docRef = firestore.doc('users/${{ github.event.inputs.user_id }}/builds/${{ github.event.inputs.build_id }}');
            await docRef.update({
              status: 'completed',
              downloadUrl: 'https://sourceforge.net/projects/${{ secrets.SF_PROJECT_NAME }}/files/${{ github.event.inputs.openwrt_version }}/${{ github.event.inputs.device_profile }}/${{ steps.organize_files.outputs.RENAMED_FILE }}/download'
            });
            console.log('Successfully updated Firestore document with status: completed');

      - name: 'Report Failure to Firestore'
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const { Firestore } = require('@google-cloud/firestore');
            const firestore = new Firestore({
              projectId: 'peditxos',
              credentials: JSON.parse('${{ secrets.GCP_SA_KEY }}')
            });
            const docRef = firestore.doc('users/${{ github.event.inputs.user_id }}/builds/${{ github.event.inputs.build_id }}');
            await docRef.update({
              status: 'failed',
              downloadUrl: null
            });
            console.log('Successfully updated Firestore document with status: failed');
