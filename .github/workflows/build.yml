name: 'PeDitXOS Firmware Builder'

on:
  workflow_dispatch:
    inputs:
      user_id:
        description: 'Firebase User ID'
        required: true
        type: string
      build_id:
        description: 'Firestore Build ID'
        required: true
        type: string
      device_target:
        description: 'Device Target'
        required: true
        type: string
      device_profile:
        description: 'Device Profile'
        required: true
        type: string
      target_arch:
        description: 'Target Architecture (e.g., x86_64, aarch64_cortex-a53)'
        required: true
        type: string
      openwrt_version:
        description: 'OpenWrt Version'
        required: true
        type: string
      extra_packages:
        description: 'Extra packages'
        required: false
        type: string
      theme_choice:
        description: 'Selected LuCI theme (luci-theme-peditx or luci-theme-carbonpx)'
        required: true
        type: string
      lan_ip:
        description: 'The LAN IP address'
        required: false
        type: string
      wifi_24_enabled:
        description: 'Enable 2.4GHz WiFi'
        required: false
        type: string

jobs:
  build_firmware:
    name: Build Firmware
    runs-on: ubuntu-latest

    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4

      - name: 'Install Build Dependencies'
        run: |
          sudo apt-get update
          sudo apt-get install -y wget tar make coreutils rsync openssh-client curl jq zstd unzip lftp

      - name: 'Authenticate to Google Cloud'
        id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}'

      - name: 'Download and Extract OpenWrt ImageBuilder'
        id: download_ib
        run: |
          TARGET_DIR_URL="https://downloads.openwrt.org/releases/${{ github.event.inputs.openwrt_version }}/targets/${{ github.event.inputs.device_target }}"
          IMAGEBUILDER_FILENAME=$(curl -s "${TARGET_DIR_URL}/" | grep -o 'href="[^"]*imagebuilder[^"]*\.tar\.\(xz\|zst\)"' | head -n 1 | sed 's/href="//;s/"//')
          if [ -z "$IMAGEBUILDER_FILENAME" ]; then
            echo "::error::Could not automatically find the ImageBuilder filename."
            exit 1
          fi
          echo "IMAGEBUILDER_FILENAME=${IMAGEBUILDER_FILENAME}" >> $GITHUB_OUTPUT
          IMAGEBUILDER_URL="${TARGET_DIR_URL}/${IMAGEBUILDER_FILENAME}"
          wget "${IMAGEBUILDER_URL}"
          mkdir imagebuilder
          tar -xf "${IMAGEBUILDER_FILENAME}" --strip-components=1 -C imagebuilder

      - name: 'Prepare ImageBuilder Environment'
        run: |
          IMAGEBUILDER_DIR="imagebuilder"
          echo "IMAGEBUILDER_DIR=${IMAGEBUILDER_DIR}" >> $GITHUB_ENV
          TARGET_ARCH="${{ github.event.inputs.target_arch }}"
          echo "TARGET_ARCH=${TARGET_ARCH}" >> $GITHUB_ENV
          REPO_CONF_FILE="${IMAGEBUILDER_DIR}/repositories.conf"
          sed -i 's/^option check_signature.*/option check_signature 0/' "${REPO_CONF_FILE}"
          echo "--- Signature check disabled ---"

      - name: 'Prepare Custom Files and Scripts'
        run: |
          FILES_DIR="${{ github.workspace }}/files"
          mkdir -p "${FILES_DIR}/etc"
          
          # --- Create final branded release files from scratch (pre-build) ---
          cat << EOF > "${FILES_DIR}/etc/openwrt_release"
          DISTRIB_ID='PeDitXOS'
          DISTRIB_RELEASE='PeDitXOS (${{ github.event.inputs.openwrt_version }})'
          DISTRIB_REVISION='r0+peditx'
          DISTRIB_TARGET='${{ github.event.inputs.device_target }}'
          DISTRIB_ARCH='${{ github.event.inputs.target_arch }}'
          DISTRIB_DESCRIPTION='PeDitXOS Telegram: @peditx'
          DISTRIB_TAINTS='no-all'
          EOF
          cat << EOF > "${FILES_DIR}/etc/os-release"
          NAME='PeDitXOS'
          VERSION='${{ github.event.inputs.openwrt_version }}'
          ID='peditxos'
          ID_LIKE='openwrt'
          PRETTY_NAME='PeDitXOS (${{ github.event.inputs.openwrt_version }})'
          VERSION_ID='${{ github.event.inputs.openwrt_version }}'
          HOME_URL='https://sourceforge.net/projects/peditxos/'
          SUPPORT_URL='https://t.me/peditx'
          BUG_REPORT_URL='https://t.me/peditx'
          OPENWRT_BOARD='${{ github.event.inputs.device_target }}'
          OPENWRT_ARCH='${{ github.event.inputs.target_arch }}'
          OPENWRT_TAINTS='no-all'
          OPENWRT_RELEASE='PeDitXOS (${{ github.event.inputs.openwrt_version }})'
          EOF
          echo "--- Final branded release files generated ---"

          # --- Create custom feeds file directly ---
          OPENWRT_RELEASE_BASE=$(echo "${{ github.event.inputs.openwrt_version }}" | cut -d. -f1-2)
          TARGET_ARCH_VAR="${{ github.event.inputs.target_arch }}"
          CUSTOM_FEEDS_DIR="${FILES_DIR}/etc/opkg"
          mkdir -p "${CUSTOM_FEEDS_DIR}"
          CUSTOM_FEEDS_FILE="${CUSTOM_FEEDS_DIR}/customfeeds.conf"
          echo "# PeDitXOS Custom Feeds" > "${CUSTOM_FEEDS_FILE}"
          for feed in passwall_luci passwall_packages passwall2; do
            echo "src/gz $feed https://repo.peditxdl.ir/passwall-packages/releases/packages-${OPENWRT_RELEASE_BASE}/${TARGET_ARCH_VAR}/$feed" >> "${CUSTOM_FEEDS_FILE}"
          done
          echo "--- Custom feeds file generated ---"

          # --- Create UCI Defaults Script ---
          UCI_SCRIPT_DIR="${FILES_DIR}/etc/uci-defaults"
          mkdir -p "${UCI_SCRIPT_DIR}"
          UCI_SCRIPT_PATH="${UCI_SCRIPT_DIR}/99-peditxos-settings"
          
          echo "#!/bin/sh" > "${UCI_SCRIPT_PATH}"
          
          # --- Add Custom opkg key on first boot ---
          cat << 'EOF_SCRIPT' >> "${UCI_SCRIPT_PATH}"
          # Add new opkg key
          wget -O /tmp/passwall.pub https://repo.peditxdl.ir/passwall-packages/passwall.pub
          opkg-key add /tmp/passwall.pub
          rm /tmp/passwall.pub
          EOF_SCRIPT

          # UCI settings
          THEME_NAME=$(echo "${{ github.event.inputs.theme_choice }}" | sed 's/luci-theme-//')
          echo "uci -q batch <<EOF" >> "${UCI_SCRIPT_PATH}"
          echo "set system.@system[0].hostname='PeDitXOS'" >> "${UCI_SCRIPT_PATH}"
          echo "set system.@system[0].description='PeDitXOS (Built for ${{ github.event.inputs.device_profile }})'" >> "${UCI_SCRIPT_PATH}"
          echo "set system.@system[0].timezone='Asia/Tehran'" >> "${UCI_SCRIPT_PATH}"
          echo "set system.@system[0].zonename='IRT+3:30'" >> "${UCI_SCRIPT_PATH}"
          echo "set system.@system[0].ntpserver='ir.pool.ntp.org time.cloudflare.com'" >> "${UCI_SCRIPT_PATH}"
          echo "set network.wan.dns='8.8.8.8 8.8.4.4'" >> "${UCI_SCRIPT_PATH}"
          echo "set luci.main.mediaurlbase='/luci-static/${THEME_NAME}'" >> "${UCI_SCRIPT_PATH}"

          if [ -n "${{ github.event.inputs.lan_ip }}" ]; then
            echo "set network.lan.ipaddr='${{ github.event.inputs.lan_ip }}'" >> "${UCI_SCRIPT_PATH}"
            echo "set dhcp.lan.start='100'" >> "${UCI_SCRIPT_PATH}"
            echo "set dhcp.lan.limit='150'" >> "${UCI_SCRIPT_PATH}"
            echo "set dhcp.lan.interface='lan'" >> "${UCI_SCRIPT_PATH}"
          fi
          
          if [ "${{ github.event.inputs.wifi_24_enabled }}" = "false" ]; then
            echo "set wireless.radio0.disabled='1'" >> "${UCI_SCRIPT_PATH}"
          else
            echo "set wireless.radio0.disabled='0'" >> "${UCI_SCRIPT_PATH}"
          fi

          echo "commit" >> "${UCI_SCRIPT_PATH}"
          echo "EOF" >> "${UCI_SCRIPT_PATH}"
          echo "rm -rf /tmp/luci-cache/*" >> "${UCI_SCRIPT_PATH}"
          echo "service uhttpd restart" >> "${UCI_SCRIPT_PATH}"
          echo "/sbin/reload_config" >> "${UCI_SCRIPT_PATH}"
          
          chmod +x "${UCI_SCRIPT_PATH}"
          echo "--- Custom UCI script generated ---"

      - name: 'Download Custom IPK Packages'
        run: |
          CUSTOM_PKG_DIR="${{ env.IMAGEBUILDER_DIR }}/packages"
          mkdir -p "${CUSTOM_PKG_DIR}"
          
          # A robust function to download the correct IPK package from a GitHub release.
          # It prioritizes 'all' architecture packages, then falls back to arch-specific ones.
          download_release_ipk() {
            local REPO_NAME="$1"
            # An optional second argument for the package name if it differs from the repo name
            local PKG_NAME_BASE=${2:-$REPO_NAME} 

            echo "--> Searching for package '${PKG_NAME_BASE}' in repo '${REPO_NAME}'..."
            local API_URL="https://api.github.com/repos/peditx/${REPO_NAME}/releases/latest"
            local API_RESPONSE=$(curl -sL "$API_URL")
            
            if ! echo "${API_RESPONSE}" | jq -e '.tag_name' > /dev/null; then
              echo "::warning::Could not fetch latest release for ${REPO_NAME}. Skipping package."
              return 1
            fi

            local LATEST_VERSION=$(echo "${API_RESPONSE}" | jq -r '.tag_name')
            local IPK_URL=""
            local FOUND_FILENAME=""

            # Priority 1: Find 'all' package (most common for LuCI apps)
            local ALL_PKG_FILENAME="${PKG_NAME_BASE}_${LATEST_VERSION}_all.ipk"
            IPK_URL=$(echo "${API_RESPONSE}" | jq -r --arg FILENAME "${ALL_PKG_FILENAME}" '.assets[] | select(.name == $FILENAME) | .browser_download_url')
            
            if [ -n "$IPK_URL" ] && [ "$IPK_URL" != "null" ]; then
              FOUND_FILENAME=$ALL_PKG_FILENAME
            else
              # Priority 2: Fallback to architecture-specific package
              local ARCH_PKG_FILENAME="${PKG_NAME_BASE}_${LATEST_VERSION}_${{ env.TARGET_ARCH }}.ipk"
              IPK_URL=$(echo "${API_RESPONSE}" | jq -r --arg FILENAME "${ARCH_PKG_FILENAME}" '.assets[] | select(.name == $FILENAME) | .browser_download_url')
              if [ -n "$IPK_URL" ] && [ "$IPK_URL" != "null" ]; then
                FOUND_FILENAME=$ARCH_PKG_FILENAME
              fi
            fi

            if [ -n "$FOUND_FILENAME" ]; then
              wget -q "$IPK_URL" -P "${CUSTOM_PKG_DIR}"
              echo "--> Successfully downloaded ${FOUND_FILENAME}"
              return 0 # Success
            else
              echo "::warning::Could not find a compatible '${PKG_NAME_BASE}' package for arch '${{ env.TARGET_ARCH }}' or 'all'."
              return 1 # Failure
            fi
          }

          download_passwall_bundle() {
            local REPO_NAME="$1"
            local PKG_NAME_BASE="$2"
            echo "--> Preparing bundle for ${PKG_NAME_BASE}..."
            
            # Download the main LuCI package using the robust function
            download_release_ipk "${REPO_NAME}" "${PKG_NAME_BASE}"
            
            # Download the architecture-specific dependency bundle
            local API_URL="https://api.github.com/repos/peditx/${REPO_NAME}/releases/latest"
            local API_RESPONSE=$(curl -sL "$API_URL")
            if echo "${API_RESPONSE}" | jq -e '.assets' > /dev/null; then
              local ZIP_FILENAME="passwall_packages_ipk_${{ env.TARGET_ARCH }}.zip"
              local ZIP_URL=$(echo "${API_RESPONSE}" | jq -r --arg FILENAME "${ZIP_FILENAME}" '.assets[] | select(.name == $FILENAME) | .browser_download_url')
              if [ -n "$ZIP_URL" ] && [ "$ZIP_URL" != "null" ]; then
                wget -q "${ZIP_URL}" -O dependencies.zip
                unzip -qo dependencies.zip -d "${CUSTOM_PKG_DIR}"
                rm dependencies.zip
                echo "--> Successfully downloaded dependency bundle for ${PKG_NAME_BASE}"
              else
                echo "::warning::Could not find dependency bundle for ${PKG_NAME_BASE} (arch: ${{ env.TARGET_ARCH }})."
              fi
            else
                echo "::warning::Could not find a valid release for ${REPO_NAME} to get dependency bundle."
            fi
          }

          # Download themes and themeswitch
          download_release_ipk "luci-theme-peditx"
          download_release_ipk "luci-theme-carbonpx"
          download_release_ipk "luci-app-themeswitch"
          
          # Download extra packages if selected
          for pkg in ${{ github.event.inputs.extra_packages }}; do
            if [[ "$pkg" == "luci-app-passwall" ]]; then
              download_passwall_bundle "openwrt-passwall" "luci-app-passwall"
            fi
            if [[ "$pkg" == "luci-app-passwall2" ]]; then
              download_passwall_bundle "openwrt-passwall2" "luci-app-passwall2"
            fi
          done
    
      - name: 'Build Firmware Image'
        id: build_image
        run: |
          cd "${{ env.IMAGEBUILDER_DIR }}"
          make clean

          echo "--> Forcing a package index refresh to include local IPKs..."
          make package_index V=s
          
          # Determine device category for fine-tuned package selection
          IS_VERY_LIMITED_FLASH=false
          IS_SBC=false
          case "${{ github.event.inputs.device_profile }}" in
            *xiaomi_mi-router-4a-gigabit*) # Add other 16MB flash devices here
              IS_VERY_LIMITED_FLASH=true
              ;;
            *nanopi*|*bananapi*|*orangepi*|*rpi*)
              IS_SBC=true
              ;;
          esac

          # Start with the user's selected packages
          FINAL_EXTRA_PACKAGES="${{ github.event.inputs.extra_packages }}"

          # Apply package filtering logic based on device constraints
          if [[ "$IS_VERY_LIMITED_FLASH" == "true" ]]; then
            # Priority logic for passwall on 16MB devices
            if [[ " $FINAL_EXTRA_PACKAGES " =~ " luci-app-passwall " && " $FINAL_EXTRA_PACKAGES " =~ " luci-app-passwall2 " ]]; then
              echo "::warning::Both passwall and passwall2 were selected for a 16MB device. Removing 'luci-app-passwall' to prioritize 'luci-app-passwall2'."
              FINAL_EXTRA_PACKAGES=$(echo " $FINAL_EXTRA_PACKAGES " | sed 's/ luci-app-passwall / /g' | xargs)
            fi
          fi

          if [[ "$IS_VERY_LIMITED_FLASH" == "true" || "$IS_SBC" == "true" ]]; then
            echo "::notice::Space-constrained device detected. Checking heavy package count."
            HEAVY_PKG_COUNT=0
            HEAVY_PACKAGES="luci-app-passwall luci-app-passwall2 luci-app-wol luci-app-smartdns"
            for pkg in $HEAVY_PACKAGES; do
              # Count from the potentially modified package list
              if [[ " $FINAL_EXTRA_PACKAGES " =~ " ${pkg} " ]]; then
                HEAVY_PKG_COUNT=$((HEAVY_PKG_COUNT + 1))
              fi
            done
            
            # Set package count threshold based on device type
            THRESHOLD=2 # Default for SBCs
            if [[ "$IS_VERY_LIMITED_FLASH" == "true" ]]; then
              THRESHOLD=1 # Stricter limit for 16MB devices
            fi

            if (( HEAVY_PKG_COUNT > THRESHOLD )); then
              echo "::warning::Too many heavy packages remain (Count: $HEAVY_PKG_COUNT, Max: $THRESHOLD). Removing lower-priority packages (wol, smartdns)."
              FINAL_EXTRA_PACKAGES=$(echo " $FINAL_EXTRA_PACKAGES " | sed 's/ luci-app-wol / /g' | sed 's/ luci-app-smartdns / /g' | xargs)
            fi
          fi

          # Conditionally include themes. Very limited devices do not get them to save space.
          THEME_PACKAGES="luci-theme-peditx luci-theme-carbonpx" # Start with base themes
          
          # Check if themeswitch was downloaded before adding it to the list
          if ls packages/luci-app-themeswitch*.ipk 1> /dev/null 2>&1; then
             echo "Themeswitch package found, adding it to the build."
             THEME_PACKAGES="${THEME_PACKAGES} luci-app-themeswitch"
          else
             echo "Themeswitch package not found, excluding it from the build."
          fi

          if [[ "$IS_VERY_LIMITED_FLASH" == "true" ]]; then
            echo "::warning::Very limited flash device (16MB) detected. Removing all themes to save critical space."
            THEME_PACKAGES=""
          fi
          
          BASE_PACKAGES="luci luci-ssl luci-compat curl screen sshpass procps-ng-pkill luci-app-ttyd coreutils coreutils-base64 coreutils-nohup"
          ALL_PACKAGES="${BASE_PACKAGES} ${THEME_PACKAGES} -luci-theme-bootstrap -dnsmasq ${FINAL_EXTRA_PACKAGES}"
          
          echo "Building with Profile: ${{ github.event.inputs.device_profile }}"
          echo "Final Packages: ${ALL_PACKAGES}"

          # Force a large RootFS size ONLY for x86 targets, as they have ample disk space.
          if [[ "${{ github.event.inputs.device_target }}" == "x86/64" || "${{ github.event.inputs.target_arch }}" == "i386_pentium4" ]]; then
            echo "x86 target detected. Forcing RootFS size to 512MB."
            sed -i '/CONFIG_TARGET_ROOTFS_PARTSIZE/d' .config
            echo "CONFIG_TARGET_ROOTFS_PARTSIZE=512" >> .config
          else
            echo "Using default RootFS size defined by the device profile."
          fi
          
          # Now, run the standard make command.
          make image PROFILE="${{ github.event.inputs.device_profile }}" \
            PACKAGES="${ALL_PACKAGES}" \
            FILES="${{ github.workspace }}/files" \
            BIN_DIR="${{ github.workspace }}/output" V=s

      - name: 'Upload build logs on failure'
        if: failure() && steps.build_image.outcome == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: build-logs
          path: ${{ env.IMAGEBUILDER_DIR }}/logs/

      - name: 'List Output Directory Contents'
        if: always()
        run: |
          echo "--- Listing contents of output directory ---"
          ls -R ${{ github.workspace }}/output

      - name: 'Organize, Rename, and Compress Files'
        id: organize_files
        run: |
          cd "${{ github.workspace }}/output"
          echo "--- Searching for firmware files. Listing all files for debugging: ---"
          ls -lR
          
          # New, comprehensive logic to find the primary flashable image with prioritization.
          PRIMARY_IMAGE=""

          # Priority 1: Specific sysupgrade images (most common and safe).
          PRIMARY_IMAGE=$(find . -maxdepth 1 \( \
            -name "*squashfs-sysupgrade.bin" -o \
            -name "*ext4-sysupgrade.img.gz" -o \
            -name "*nand-sysupgrade.bin" -o \
            -name "*ubi-sysupgrade.img" -o \
            -name "*sysupgrade.itb" -o \
            -name "*sysupgrade.bin" \
            \) -print -quit)

          # Priority 2: SBC, VM, and other specific target images.
          if [ -z "$PRIMARY_IMAGE" ]; then
            PRIMARY_IMAGE=$(find . -maxdepth 1 \( \
              -name "*sdcard.img.gz" -o \
              -name "*sdcard.img.xz" -o \
              -name "*.sdimg" -o \
              -name "*.wic" -o \
              -name "*squashfs-combined-efi.img.gz" -o \
              -name "*.vdi" -o \
              -name "*.vmdk" -o \
              -name "*.qcow2" -o \
              -name "*.vhdx" \
              \) -print -quit)
          fi
          
          # Priority 3: Factory and legacy images.
          if [ -z "$PRIMARY_IMAGE" ]; then
            PRIMARY_IMAGE=$(find . -maxdepth 1 \( \
              -name "*factory.bin" -o \
              -name "*factory.img" -o \
              -name "*.trx" -o \
              -name "*.chk" \
              \) -print -quit)
          fi

          # Priority 4: Generic but common image types (last resort).
          if [ -z "$PRIMARY_IMAGE" ]; then
            PRIMARY_IMAGE=$(find . -maxdepth 1 \( \
              -name "*.ubi" -o \
              -name "*.ubifs" -o \
              -name "*.img" -o \
              -name "*.bin" \
              \) -print -quit)
          fi
          
          # Check if an image was found and handle the result.
          if [ -z "$PRIMARY_IMAGE" ]; then
            echo "::error::Build failed. No flashable image was found in the output directory."
            echo "This almost always means the 'Build Firmware Image' step encountered a fatal error (like the firmware being too large for the device)."
            echo "Please download and check the 'build-logs' artifact from this failed run to see the real reason for the failure."
            exit 1
          fi

          # Remove './' prefix from find result if it exists
          PRIMARY_IMAGE="${PRIMARY_IMAGE#./}"
          echo "Primary image found: ${PRIMARY_IMAGE}"
          
          for f in openwrt-*; do mv -- "$f" "PeDitXOS-${f#openwrt-}"; done
          rm -f *.json

          TIMESTAMP=$(date +'%Y-%m-%d_%H-%M-%S')
          ARCHIVE_NAME="PeDitXOS-${{ github.event.inputs.device_profile }}-${TIMESTAMP}.zip"
          
          zip -r "${ARCHIVE_NAME}" .
          
          echo "ARCHIVE_NAME=${ARCHIVE_NAME}" >> $GITHUB_OUTPUT
          echo "TIMESTAMP=${TIMESTAMP}" >> $GITHUB_OUTPUT

      - name: 'Upload Firmware to SourceForge'
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SF_USERNAME: ${{ secrets.SF_USERNAME }}
          SF_PROJECT_NAME: ${{ secrets.SF_PROJECT_NAME }}
        run: |
          mkdir -p ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H frs.sourceforge.net >> ~/.ssh/known_hosts
          
          REMOTE_BASE_DIR="/home/frs/project/${SF_PROJECT_NAME}/users"
          REMOTE_UPLOAD_DIR="${REMOTE_BASE_DIR}/${{ github.event.inputs.user_id }}/${{ steps.organize_files.outputs.TIMESTAMP }}"
          LOCAL_FILE_PATH="${{ github.workspace }}/output/${{ steps.organize_files.outputs.ARCHIVE_NAME }}"

          echo "Connecting to sftp://frs.sourceforge.net as user ${SF_USERNAME}"
          echo "Remote directory to create: ${REMOTE_UPLOAD_DIR}"
          echo "Local file to upload: ${LOCAL_FILE_PATH}"
          
          lftp -c "
          set sftp:connect-program 'ssh -a -x -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes';
          open -u ${SF_USERNAME}, sftp://frs.sourceforge.net;
          mkdir -p ${REMOTE_UPLOAD_DIR};
          cd ${REMOTE_UPLOAD_DIR};
          put ${LOCAL_FILE_PATH};
          bye;
          "
          
          rm -f ~/.ssh/id_rsa
          echo "Upload complete."

      - name: 'Report Success to Firestore'
        if: success()
        run: |
          echo "--> Updating Firestore (success)..."
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          PROJECT_ID="${{ steps.auth.outputs.project_id }}"
          
          DOWNLOAD_URL="https://sourceforge.net/projects/${{ secrets.SF_PROJECT_NAME }}/files/users/${{ github.event.inputs.user_id }}/${{ steps.organize_files.outputs.TIMESTAMP }}/${{ steps.organize_files.outputs.ARCHIVE_NAME }}"
          
          JSON_PAYLOAD=$(cat <<EOF
          {
            "fields": {
              "status": { "stringValue": "completed" },
              "downloadUrl": { "stringValue": "${DOWNLOAD_URL}" }
            }
          }
          EOF
          )

          curl --fail -X PATCH \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -d "${JSON_PAYLOAD}" \
            "https://firestore.googleapis.com/v1/projects/${PROJECT_ID}/databases/(default)/documents/users/${{ github.event.inputs.user_id }}/builds/${{ github.event.inputs.build_id }}?updateMask.fieldPaths=status&updateMask.fieldPaths=downloadUrl"
            
          echo "Firestore update successful."

      - name: 'Report Failure to Firestore'
        if: failure()
        run: |
          echo "--> Updating Firestore (failure)..."
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          PROJECT_ID="${{ steps.auth.outputs.project_id }}"

          JSON_PAYLOAD=$(cat <<EOF
          {
            "fields": {
              "status": { "stringValue": "failed" },
              "downloadUrl": { "nullValue": null }
            }
          }
          EOF
          )

          curl --fail -X PATCH \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -d "${JSON_PAYLOAD}" \
            "https://firestore.googleapis.com/v1/projects/${PROJECT_ID}/databases/(default)/documents/users/${{ github.event.inputs.user_id }}/builds/${{ github.event.inputs.build_id }}?updateMask.fieldPaths=status&updateMask.fieldPaths=downloadUrl"
            
          echo "Firestore update successful."

