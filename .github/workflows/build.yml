name: 'PeDitXOS Firmware Builder'

on:
  workflow_dispatch:
    inputs:
      user_id:
        description: 'Firebase User ID'
        required: true
        type: string
      build_id:
        description: 'Firestore Build ID'
        required: true
        type: string
      device_target:
        description: 'Device Target'
        required: true
        type: string
      device_profile:
        description: 'Device Profile'
        required: true
        type: string
      target_arch:
        description: 'Target Architecture'
        required: true
        type: string
      openwrt_version:
        description: 'OpenWrt Version'
        required: true
        type: string
      extra_packages:
        description: 'Extra packages'
        required: false
        type: string
      theme_choice:
        description: 'Selected LuCI theme'
        required: true
        type: string
      lan_ip:
        description: 'The LAN IP address'
        required: false
        type: string
      wifi_24_enabled:
        description: 'Enable 2.4GHz WiFi'
        required: false
        type: string

jobs:
  build_firmware:
    name: Build Firmware
    runs-on: ubuntu-latest

    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4

      - name: 'Install Build Dependencies'
        run: |
          sudo apt-get update
          sudo apt-get install -y wget tar make coreutils rsync openssh-client curl jq zstd unzip lftp

      - name: 'Authenticate to Google Cloud'
        id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}'

      - name: 'Download and Extract OpenWrt ImageBuilder'
        id: download_ib
        run: |
          TARGET_DIR_URL="https://downloads.openwrt.org/releases/${{ github.event.inputs.openwrt_version }}/targets/${{ github.event.inputs.device_target }}"
          IMAGEBUILDER_FILENAME=$(curl -s "${TARGET_DIR_URL}/" | grep -o 'href="[^"]*imagebuilder[^"]*\.tar\.\(xz\|zst\)"' | head -n 1 | sed 's/href="//;s/"//')
          if [ -z "$IMAGEBUILDER_FILENAME" ]; then
            echo "::error::Could not automatically find the ImageBuilder filename."
            exit 1
          fi
          echo "IMAGEBUILDER_FILENAME=${IMAGEBUILDER_FILENAME}" >> $GITHUB_OUTPUT
          IMAGEBUILDER_URL="${TARGET_DIR_URL}/${IMAGEBUILDER_FILENAME}"
          wget "${IMAGEBUILDER_URL}"
          mkdir imagebuilder
          tar -xf "${IMAGEBUILDER_FILENAME}" --strip-components=1 -C imagebuilder

      - name: 'Prepare ImageBuilder Environment'
        run: |
          IMAGEBUILDER_DIR="imagebuilder"
          echo "IMAGEBUILDER_DIR=${IMAGEBUILDER_DIR}" >> $GITHUB_ENV
          TARGET_ARCH="${{ github.event.inputs.target_arch }}"
          echo "TARGET_ARCH=${TARGET_ARCH}" >> $GITHUB_ENV
          REPO_CONF_FILE="${IMAGEBUILDER_DIR}/repositories.conf"
          sed -i 's/^option check_signature.*/option check_signature 0/' "${REPO_CONF_FILE}"
          echo "--- Signature check disabled ---"
      
      - name: 'Determine if Target is an SBC (for rootfs resize)'
        id: sbc_check
        run: |
          IS_SBC="false"
          # First, always treat x86 as an SBC
          if [[ "${{ github.event.inputs.device_target }}" == "x86/64" ]]; then
            IS_SBC="true"
          else
            # Stage 1: Check IMAGE_SIZE from Makefile for a reliable detection
            echo "Checking profile configuration for: ${{ github.event.inputs.device_profile }}"
            MAKEFILE_PATH=$(find ${{ env.IMAGEBUILDER_DIR }}/target/linux -type f -name 'Makefile' | head -n 1)

            if [ -z "$MAKEFILE_PATH" ]; then
              echo "::warning::Could not find target Makefile. Will rely on profile name check."
            else
              DEVICE_BLOCK=$(sed -n "/define Device\/${{ github.event.inputs.device_profile }}/,/endef/p" "$MAKEFILE_PATH")
              IMAGE_SIZE_RAW=$(echo "$DEVICE_BLOCK" | grep -o 'IMAGE_SIZE :=.*' | cut -d' ' -f3)
              echo "Found raw IMAGE_SIZE value: '${IMAGE_SIZE_RAW}'"

              if [ -n "$IMAGE_SIZE_RAW" ]; then
                SIZE_MB=0
                if [[ "$IMAGE_SIZE_RAW" == *k ]]; then
                  SIZE_KB=${IMAGE_SIZE_RAW//k/}
                  SIZE_MB=$((SIZE_KB / 1024))
                elif [[ "$IMAGE_SIZE_RAW" == *M ]]; then
                  SIZE_MB=${IMAGE_SIZE_RAW//M/}
                elif [[ "$IMAGE_SIZE_RAW" == *G ]]; then
                  SIZE_GB=${IMAGE_SIZE_RAW//G/}
                  SIZE_MB=$((SIZE_GB * 1024))
                else
                  if [[ "$IMAGE_SIZE_RAW" -gt 1000000 ]]; then
                    SIZE_MB=$((IMAGE_SIZE_RAW / 1024 / 1024))
                  else
                    SIZE_MB=$IMAGE_SIZE_RAW
                  fi
                fi
                echo "Calculated default image size is approximately: ${SIZE_MB}MB"
                if [ "$SIZE_MB" -gt 256 ]; then
                  IS_SBC="true"
                fi
              fi
            fi
            
            # Stage 2 (Fallback): If size check didn't confirm, check profile name for keywords
            if [ "$IS_SBC" == "false" ]; then
              echo "IMAGE_SIZE check did not confirm SBC. Falling back to profile name check."
              if echo "${{ github.event.inputs.device_profile }}" | grep -Eq 'nanopi|raspberry|rpi|rockpro|rockpi|orange|banana|x86'; then
                echo "Profile name contains SBC keyword. Treating as SBC."
                IS_SBC="true"
              fi
            fi
          fi
          
          echo "Decision: This device will be treated as an SBC: $IS_SBC"
          echo "is_sbc=$IS_SBC" >> $GITHUB_OUTPUT

      - name: 'Generate Custom Scripts and Settings'
        run: |
          UCI_SCRIPT_DIR="${{ github.workspace }}/files/etc/uci-defaults"
          mkdir -p "${UCI_SCRIPT_DIR}"
          UCI_SCRIPT_PATH="${UCI_SCRIPT_DIR}/99-peditxos-settings"
          
          THEME_NAME=$(echo "${{ github.event.inputs.theme_choice }}" | sed 's/luci-theme-//')

          echo "#!/bin/sh" > "${UCI_SCRIPT_PATH}"
          
          echo "sed -i 's/DISTRIB_RELEASE=.*/DISTRIB_RELEASE=\"PeDitXOS (${{ github.event.inputs.openwrt_version }})\"/' /etc/openwrt_release" >> "${UCI_SCRIPT_PATH}"
          echo "sed -i 's/DISTRIB_DESCRIPTION=.*/DISTRIB_DESCRIPTION=\"PeDitXOS Telegram: @peditx\"/' /etc/openwrt_release" >> "${UCI_SCRIPT_PATH}"

          echo "sed -i 's/^NAME=.*/NAME=\"PeDitXOS\"/' /etc/os-release" >> "${UCI_SCRIPT_PATH}"
          echo "sed -i 's/^PRETTY_NAME=.*/PRETTY_NAME=\"PeDitXOS (${{ github.event.inputs.openwrt_version }})\"/' /etc/os-release" >> "${UCI_SCRIPT_PATH}"

          echo "uci -q batch <<EOF" >> "${UCI_SCRIPT_PATH}"
          echo "set system.@system[0].hostname='PeDitXOS'" >> "${UCI_SCRIPT_PATH}"
          echo "set luci.main.mediaurlbase='/luci-static/${THEME_NAME}'" >> "${UCI_SCRIPT_PATH}"
          
          if [ -n "${{ github.event.inputs.lan_ip }}" ]; then
            echo "set network.lan.ipaddr='${{ github.event.inputs.lan_ip }}'" >> "${UCI_SCRIPT_PATH}"
            echo "set network.lan.proto='static'" >> "${UCI_SCRIPT_PATH}"
            echo "set dhcp.lan.start='100'" >> "${UCI_SCRIPT_PATH}"
            echo "set dhcp.lan.limit='150'" >> "${UCI_SCRIPT_PATH}"
            echo "set dhcp.lan.leasetime='12h'" >> "${UCI_SCRIPT_PATH}"
          fi

          if [ "${{ github.event.inputs.wifi_24_enabled }}" = "true" ]; then
            echo "set wireless.radio0.disabled='0'" >> "${UCI_SCRIPT_PATH}"
          else
            echo "set wireless.radio0.disabled='1'" >> "${UCI_SCRIPT_PATH}"
          fi

          echo "commit" >> "${UCI_SCRIPT_PATH}"
          echo "EOF" >> "${UCI_SCRIPT_PATH}"
          chmod +x "${UCI_SCRIPT_PATH}"
          echo "--- Custom settings script generated ---"
          cat "${UCI_SCRIPT_PATH}"

      - name: 'Download Custom IPK Packages'
        run: |
          CUSTOM_PKG_DIR="${{ env.IMAGEBUILDER_DIR }}/packages"
          mkdir -p "${CUSTOM_PKG_DIR}"
          
          # Downloads the latest .ipk file from a given GitHub repo release
          download_latest_ipk() {
            local REPO_NAME="$1"
            local API_URL="https://api.github.com/repos/peditx/${REPO_NAME}/releases/latest"
            local API_RESPONSE=$(curl -sL "$API_URL")
            if echo "${API_RESPONSE}" | jq -e '.assets' > /dev/null; then
              local IPK_URL=$(echo "${API_RESPONSE}" | jq -r '.assets[] | select(.name | endswith(".ipk")) | .browser_download_url' | head -n 1)
              if [ -n "$IPK_URL" ]; then
                wget -q "$IPK_URL" -P "${CUSTOM_PKG_DIR}"
                echo "--> Successfully downloaded ${REPO_NAME}"
              else
                echo "::warning::Found a release for ${REPO_NAME}, but no .ipk file was found."
              fi
            else
              echo "::warning::Could not find a valid release for ${REPO_NAME}. Skipping."
            fi
          }

          # Downloads the main passwall app and its dependency bundle for the target architecture
          download_passwall_bundle() {
            local PASSWALL_REPO="$1"
            echo "--> Attempting to download main package and dependency bundle for ${PASSWALL_REPO}..."
            download_latest_ipk "${PASSWALL_REPO}" # Download the main .ipk
            
            local API_URL="https://api.github.com/repos/peditx/${PASSWALL_REPO}/releases/latest"
            local API_RESPONSE=$(curl -sL "$API_URL")
            if echo "${API_RESPONSE}" | jq -e '.assets' > /dev/null; then
              # Flexibly search for a zip file containing the target architecture
              local ARCH_TAG="${{ env.TARGET_ARCH }}"
              local ZIP_URL=$(echo "${API_RESPONSE}" | jq -r --arg ARCH "${ARCH_TAG}" '.assets[] | select(.name | endswith(".zip") and contains($ARCH)) | .browser_download_url' | head -n 1)
              
              if [ -n "$ZIP_URL" ]; then
                echo "Found dependency bundle: ${ZIP_URL}"
                wget -q "${ZIP_URL}" -O dependencies.zip
                unzip -o dependencies.zip -d "${CUSTOM_PKG_DIR}"
                rm dependencies.zip
                echo "--> Successfully downloaded and extracted dependency bundle for ${PASSWALL_REPO}"
              else
                echo "::warning::Could not find dependency bundle for ${PASSWALL_REPO} and architecture ${ARCH_TAG}."
              fi
            else
               echo "::warning::Could not find a valid release to download dependency bundle for ${PASSWALL_REPO}. Skipping."
            fi
          }
          
          # --- Download Standard Packages ---
          echo "--> Downloading luci-app-themeswitch with architecture detection..."
          THEMESWITCH_API_URL="https://api.github.com/repos/peditx/luci-app-themeswitch/releases/latest"
          THEMESWITCH_API_RESPONSE=$(curl -sL "$THEMESWITCH_API_URL")
          LATEST_VERSION=$(echo "${THEMESWITCH_API_RESPONSE}" | jq -r '.tag_name')

          if [ -z "$LATEST_VERSION" ] || [ "$LATEST_VERSION" == "null" ]; then
            echo "::warning::Could not determine latest version for luci-app-themeswitch. Skipping."
          else
            echo "    Latest version found: ${LATEST_VERSION}"
            PKG_ARCH="${{ github.event.inputs.target_arch }}"
            echo "    Using target architecture: ${PKG_ARCH}"
            
            PKG_NAME="luci-app-themeswitch_${LATEST_VERSION}_${PKG_ARCH}.ipk"
            PKG_URL="https://github.com/peditx/luci-app-themeswitch/releases/download/${LATEST_VERSION}/${PKG_NAME}"
            
            echo "    Attempting to download from: ${PKG_URL}"
            wget -q "$PKG_URL" -P "${CUSTOM_PKG_DIR}"
            
            if [ -f "${CUSTOM_PKG_DIR}/${PKG_NAME}" ]; then
              echo "--> Successfully downloaded luci-app-themeswitch."
            else
              echo "::warning::Failed to download luci-app-themeswitch. The file was not found at the constructed URL. The build will continue without it."
            fi
          fi
          
          download_latest_ipk "luci-theme-peditx"
          download_latest_ipk "luci-theme-carbonpx"

          # --- Download Passwall if requested ---
          if echo "${{ github.event.inputs.extra_packages }}" | grep -q "\bluci-app-passwall\b"; then
            download_passwall_bundle "openwrt-passwall"
          fi
          if echo "${{ github.event.inputs.extra_packages }}" | grep -q "\bluci-app-passwall2\b"; then
            download_passwall_bundle "openwrt-passwall2"
          fi
      
      - name: 'Build Firmware Image'
        id: build_image
        run: |
          cd "${{ env.IMAGEBUILDER_DIR }}"
          make clean
          BASE_PACKAGES="luci luci-ssl luci-compat curl screen sshpass procps-ng-pkill luci-app-ttyd coreutils coreutils-base64 coreutils-nohup luci-theme-peditx luci-theme-carbonpx luci-app-themeswitch"
          ALL_PACKAGES="${BASE_PACKAGES} -luci-theme-bootstrap -dnsmasq ${{ github.event.inputs.extra_packages }}"
          echo "Building with Profile: ${{ github.event.inputs.device_profile }}"
          echo "Final Packages: ${ALL_PACKAGES}"
          
          EXTRA_MAKE_ARGS=""
          if [[ "${{ steps.sbc_check.outputs.is_sbc }}" == "true" ]]; then
            echo "SBC detected automatically. Increasing partition size to 512MB."
            EXTRA_MAKE_ARGS="TARGET_ROOTFS_PARTSIZE=512"
          else
            echo "Router or device with small flash detected. Building with default rootfs size."
          fi

          make image PROFILE="${{ github.event.inputs.device_profile }}" \
            PACKAGES="${ALL_PACKAGES}" \
            FILES="${{ github.workspace }}/files" \
            BIN_DIR="${{ github.workspace }}/output" \
            ${EXTRA_MAKE_ARGS} V=s

      - name: 'Upload build logs on failure'
        if: failure() && steps.build_image.outcome == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: build-logs
          path: ${{ env.IMAGEBUILDER_DIR }}/logs/

      - name: 'List Output Directory Contents'
        if: always()
        run: |
          echo "--- Listing contents of output directory ---"
          ls -R ${{ github.workspace }}/output

      - name: 'Organize, Rename, and Compress Files'
        id: organize_files
        run: |
          cd "${{ github.workspace }}/output"
          if [ -z "$(ls -A .)" ]; then 
            echo "::error::Build failed, no files were generated."
            exit 1
          fi
          
          PRIMARY_IMAGE=""
          if [[ -n $(find . -name "*sysupgrade.itb*" | head -n 1) ]]; then
            PRIMARY_IMAGE=$(find . -name "*sysupgrade.itb*" | head -n 1)
          elif [[ -n $(find . -name "*sysupgrade.bin*" | head -n 1) ]]; then
            PRIMARY_IMAGE=$(find . -name "*sysupgrade.bin*" | head -n 1)
          elif [[ -n $(find . -name "*sysupgrade.img.gz*" | head -n 1) ]]; then
            PRIMARY_IMAGE=$(find . -name "*sysupgrade.img.gz*" | head -n 1)
          elif [[ -n $(find . -name "*squashfs-combined-efi.img.gz*" | head -n 1) ]]; then
            PRIMARY_IMAGE=$(find . -name "*squashfs-combined-efi.img.gz*" | head -n 1)
          fi

          if [ -z "$PRIMARY_IMAGE" ]; then
            echo "::error::No primary flashable image found!"
            exit 1
          fi
          echo "Primary image found: ${PRIMARY_IMAGE}"
          
          for f in openwrt-*; do mv -- "$f" "PeDitXOS-${f#openwrt-}"; done
          rm -f *.json

          TIMESTAMP=$(date +'%Y-%m-%d_%H-%M-%S')
          ARCHIVE_NAME="PeDitXOS-${{ github.event.inputs.device_profile }}-${TIMESTAMP}.zip"
          
          zip -r "${ARCHIVE_NAME}" .
          
          echo "ARCHIVE_NAME=${ARCHIVE_NAME}" >> $GITHUB_OUTPUT
          echo "TIMESTAMP=${TIMESTAMP}" >> $GITHUB_OUTPUT

      - name: 'Upload Firmware to SourceForge'
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SF_USERNAME: ${{ secrets.SF_USERNAME }}
          SF_PROJECT_NAME: ${{ secrets.SF_PROJECT_NAME }}
        run: |
          mkdir -p ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H frs.sourceforge.net >> ~/.ssh/known_hosts
          
          REMOTE_BASE_DIR="/home/frs/project/${SF_PROJECT_NAME}/users"
          REMOTE_UPLOAD_DIR="${REMOTE_BASE_DIR}/${{ github.event.inputs.user_id }}/${{ steps.organize_files.outputs.TIMESTAMP }}"
          LOCAL_FILE_PATH="${{ github.workspace }}/output/${{ steps.organize_files.outputs.ARCHIVE_NAME }}"

          echo "Connecting to sftp://frs.sourceforge.net as user ${SF_USERNAME}"
          echo "Remote directory to create: ${REMOTE_UPLOAD_DIR}"
          echo "Local file to upload: ${LOCAL_FILE_PATH}"
          
          lftp -c "
          set sftp:connect-program 'ssh -a -x -i ~/.ssh/id_rsa -o StrictHostKeyChecking=yes';
          open -u ${SF_USERNAME}, sftp://frs.sourceforge.net;
          mkdir -p ${REMOTE_UPLOAD_DIR};
          cd ${REMOTE_UPLOAD_DIR};
          put ${LOCAL_FILE_PATH};
          bye;
          "
          
          rm -f ~/.ssh/id_rsa
          echo "Upload complete."

      - name: 'Report Success to Firestore'
        if: success()
        run: |
          echo "--> Updating Firestore (success)..."
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          PROJECT_ID="${{ steps.auth.outputs.project_id }}"
          
          DOWNLOAD_URL="https://sourceforge.net/projects/${{ secrets.SF_PROJECT_NAME }}/files/users/${{ github.event.inputs.user_id }}/${{ steps.organize_files.outputs.TIMESTAMP }}/${{ steps.organize_files.outputs.ARCHIVE_NAME }}"
          
          JSON_PAYLOAD=$(cat <<EOF
          {
            "fields": {
              "status": { "stringValue": "completed" },
              "downloadUrl": { "stringValue": "${DOWNLOAD_URL}" }
            }
          }
          EOF
          )

          curl --fail -X PATCH \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -d "${JSON_PAYLOAD}" \
            "https://firestore.googleapis.com/v1/projects/${PROJECT_ID}/databases/(default)/documents/users/${{ github.event.inputs.user_id }}/builds/${{ github.event.inputs.build_id }}?updateMask.fieldPaths=status&updateMask.fieldPaths=downloadUrl"
            
          echo "Firestore update successful."

      - name: 'Report Failure to Firestore'
        if: failure()
        run: |
          echo "--> Updating Firestore (failure)..."
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          PROJECT_ID="${{ steps.auth.outputs.project_id }}"

          JSON_PAYLOAD=$(cat <<EOF
          {
            "fields": {
              "status": { "stringValue": "failed" },
              "downloadUrl": { "nullValue": null }
            }
          }
          EOF
          )

          curl --fail -X PATCH \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -d "${JSON_PAYLOAD}" \
            "https://firestore.googleapis.com/v1/projects/${PROJECT_ID}/databases/(default)/documents/users/${{ github.event.inputs.user_id }}/builds/${{ github.event.inputs.build_id }}?updateMask.fieldPaths=status&updateMask.fieldPaths=downloadUrl"
            
          echo "Firestore update successful."
